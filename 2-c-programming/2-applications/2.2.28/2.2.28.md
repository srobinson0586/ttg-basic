# Describe the Fundamentals of Embedded Systems & Demonstrate the Ability to Cross-Compile Binaries

Requirements:
1. Read the informational sections below
2. Complete the [Knowledge Check](#knowledge-check) section in the Embedded Systems section below
3. Complete the [Cross-Compile an Application for Multiple Architectures](#cross-compile-an-application-for-multiple-architectures) section in the Cross Compiling section below

## Embedded Systems Fundamentals

Optional Videos:
- Intro video
  - [YouTube-Embedded Systems in 5 Minutes!](https://www.youtube.com/watch?v=3AXDli9tQMo)
- Playlist showcasing Router/Camera/DNS Hacking
  - [YouTube-IoT Hacking](https://www.youtube.com/playlist?list=PLfi5XR5jA2Hofpdf0i9docq9ZkP1ihenL)
- Electronics Fundamentals (to understand Hardware topics later on)
  - [YouTube-Electronics Fundamentals](https://www.youtube.com/watch?v=WlUOr4z3Lbs)

### What is an Embedded System

An embedded system is a specialized computing system designed to perform dedicated functions or tasks within a larger mechanical or electrical system. These systems are embedded directly into devices or products to control specific functions, processes, or features. They typically consist of a combination of hardware and software tailored to a particular application.

Key characteristics of embedded systems include:

1. **Dedication**: Embedded systems are designed for specific, dedicated purposes, such as controlling a washing machine, managing the engine control unit in a car, or operating a smart thermostat.

2. **Integration**: They are integrated into the devices or machines they control. You'll find embedded systems in products ranging from household appliances and consumer electronics to industrial machinery and medical devices.

3. **Real-time Operation**: Many embedded systems must operate in real-time, meaning they must respond to inputs and provide outputs within specific time constraints. For example, anti-lock braking systems in cars require real-time response to prevent accidents. This leads to many embedded systems having a [Real-Time Operating System](https://www.youtube.com/watch?v=F321087yYy4) (RTOS).

4. **Resource Constraints**: Embedded systems often have resource constraints, including limited processing power, memory, and energy. They need to operate efficiently within these constraints.

5. **Custom Hardware**: In some cases, embedded systems use custom-designed hardware components tailored to the specific application. This helps optimize performance and reduce costs.

6. **Software Control**: Embedded systems rely on software to execute tasks and manage hardware components. This software can range from simple firmware to more complex operating systems.

Examples of embedded systems are diverse, including:
- The control unit in a microwave oven.
- The firmware running on a smartwatch.
- The navigation system in an automobile.
- The micro controller in a robotic arm.
- The flight control system in drones.

Embedded systems are pervasive in our daily lives, often operating quietly behind the scenes to make devices and machines smarter, more efficient, and safer.

### Impact of Embedded System Limitations on Software Development

Embedded system programming differs from normal programming (typically associated with general-purpose software development) in several significant ways. In addition to the key characteristics listed above and their impact on development, embedded systems provide  different challenges in things like:

1. **Hardware Integration**: Embedded systems are tightly integrated with hardware components. Embedded software interacts directly with sensors, actuators, and other peripherals.
   1. Programmers need a good understanding of the hardware to develop effective embedded software.
   2. In contrast, normal programming often abstracts hardware details, focusing on higher-level software development.

2. **Custom Hardware**: Some embedded systems use custom-designed hardware components optimized for a specific application.
   1. Programmers may need to work closely with hardware engineers to ensure that the software and hardware are well-coordinated.
   2. In normal programming, developers typically work with standard, off-the-shelf hardware components.

3. **Operating Systems**: While some embedded systems use a (RTOS), many operate with minimal or no operating system (bare-metal programming).
   1. In normal programming, operating systems like Windows, Linux, or macOS are common, providing extensive services and abstractions.

4. **Testing and Debugging**: Debugging embedded systems can be more challenging due to limited debugging tools and the real-time nature of some applications.
   1. Testing and debugging normal software often involve more extensive and user-friendly tools.

5. **Security Concerns**: Embedded systems are frequently found in safety-critical applications, such as medical devices and automotive systems. Security and safety considerations are paramount in embedded programming. While security is also important in normal programming, embedded systems often have unique security requirements.

6. **Development Tools**: Embedded system programmers use specialized development tools and *cross-compilers* tailored for the target hardware.
   1. In normal programming, a broader range of general-purpose development tools is available.

7.  **Industry-specific Knowledge**: Embedded systems may be designed for various industries, such as automotive, aerospace, healthcare, or consumer electronics. Embedded programmers often need to have domain-specific knowledge to meet industry standards and regulations.

Overall, embedded system programming is a specialized field that demands a deep understanding of both hardware and software, a focus on efficiency, and the ability to work within specific constraints and real-time requirements. While it shares some similarities with normal programming, it has unique challenges and priorities.

### Knowledge Check

1. Compare and Contrast the embedded system and the laptop in the table below. Choose *any 4 technical topics*, like the fact the laptop has 16GB of DDR5 RAM while the embedded system has 512 MB DDR4 RAM.

| [ROG Strix G18 (2023) G814](https://shop.asus.com/us/rog/90nr0d01-m00260-g814ji.html) | [NETGEAR RAX30 WiFi Router](https://www.netgear.com/home/wifi/routers/rax30/) | 
| ------------- | ------------- |
|     ...       |     ...       |
|     ...       |     ...       |
|     ...       |     ...       |
|     ...       |     ...       |

2. You are a developer on a software team that is creating a VPN application. Management wants the app to work on Linux devices *and* directly on Routers, so that users can install it on their modems themselves. Think of **3 things** that you will have to do differently in your Embedded Device app (Router) from what you do in your desktop app (Linux). One example would be that in the Linux app you could build against the G-Libc library, while on the Router you would likely have to ship your own library as part of the package.
```
ANSWER:
1. 
2. 
3. 
```

## Cross-Compiling Binaries

Optional Videos:
- Intro to ISAs
  - [YouTube-What is Instruction Set Architecture](https://www.youtube.com/watch?v=6fgbLOL7bis)
- MIPS vs x86 ISA (MIPS is very common in Routers)
  - [YouTube-Comparison of MIPS and x86](https://www.youtube.com/watch?v=gUKt3rT7ZQ8)
- Compiling Windows Binaries on Linux (mingw)
  - [YouTube-Cross Compiling for Windows on Linux Tutorial](https://www.youtube.com/watch?v=3-yw-aD8CTI)

### Alternative C Libraries

This whole time you have been compiling your C programs *dynamically*, against the *GNU C Library* (glibc), and you likely haven't been thinking much about it. When you run `gcc` on a binary, you are running the [GNU Compiler Collection](https://gcc.gnu.org/) and telling it to compile your code for you. It uses *glibc* to find any functions referenced in your code and point execution to them during runtime. 

The GNU C Library is the default C library for most Linux distributions. It's highly compatible with the C standard library, offering a broad range of features and functions. It's open-source and actively maintained.

At the end of the day, a library is just code that can be called from other code. Most Linux distros use the GNU C Library, but there are several alternative C libraries for both Linux and Windows, each with its own unique features and use cases. Here are some notable C libraries for both operating systems:

**For Linux:**

1. **Musl:** Musl is a lightweight, fast, and efficient C library designed for embedded systems and lightweight Linux distributions. It's known for its minimalistic approach and is often used in projects where code size and memory footprint are critical.

2. **uClibc:** Similar to Musl, uClibc is designed for embedded systems. It's lightweight and focused on minimizing memory usage. It's suitable for systems with resource constraints.

3. **dietlibc:** dietlibc is an even more minimalistic C library designed to be small and efficient. It's not as feature-rich as glibc but is suitable for certain embedded systems where size matters.

**For Windows:**

1. **Microsoft Visual C++ Standard Library:** On Windows, the Microsoft Visual C++ Standard Library is commonly used for C and C++ development. It's integrated with Microsoft Visual Studio and provides a wide range of functions and features.

2. **Mingw-w64:** Mingw-w64 (Minimalist GNU for Windows) is a development environment for Windows that includes a port of the GNU C Library, allowing developers to use GNU development tools on Windows.

3. **Cygwin:** Cygwin provides a large collection of GNU and Open Source tools that provide functionality similar to a Linux distribution on Windows. It includes a C library to support these tools.

The choice of C library depends on the specific requirements of your project. The default libraries, *glibc* for Linux and the *Microsoft Visual C++ Standard Library* for Windows, are comprehensive and widely used. 

However, if you have specific constraints such as resource limitations in embedded systems, you may opt for lightweight alternatives like Musl, uClibc, or others. Similarly, Mingw-w64 allows you to use GNU development tools in a Windows environment.

Keep in mind that the libraries mentioned here can be used for C and C++ development, and the choice may also depend on your preferred development environment and toolchain.

### Cross-Compile an Application for Multiple Architectures

Cross-compiling on Linux involves building software for a target architecture or OS that is different from the one on which the compilation is performed. An example is the video linked above where he compiles a Windows PE file from a Linux box. Another example would be compiling a MIPS32 architecture binary on a x86_64 architecture OS.

This is a common practice when developing software for embedded systems, cross-platform applications, or other (exploitation) scenarios where the development and target platforms do not match.

In this section, you are tasked with compiling the [2.2.2/program.c](../2.2.2/program.c) program in several different architectures. Here are the specifics:
- You must compile the program for these architectures
  - PPC, 64 bit, LE
  - MIPS, 32 bit, LE
  - ARM, 32 bit, LE
- The resulting ELFs **must be Position-Independent Code** (PIC) when the tool allows
  - In normal `gcc` use, this would be achieved with the `-fPIC` flag ([docs](https://man7.org/linux/man-pages/man1/gcc.1.html))
  - Some tools may not allow PIC compilation. In that case, make a note in the below answer section
- You have to identify and install the cross-compiling tools yourself
  - You must provide the commands you executed to download each package in the section below
  - Feel free to uninstall the packages afterwards to free up space
  - There are *plenty* of tutorials out there
- The build process is up to you:
  - You may be a Cyber Capability Developer *weapon* and create a Makefile
  - OR you can just run the different cross-compilers separately
    - If this is the case, you need to include the exact commands that you ran in the answer section below
- You must provide the executables in this directory with descriptive names
  - `program_ppc64le`, `program_mips32le`, `program_arm32le`
  - When `file` and `readelf` are ran on the binaries, the output must prove the ELFs were properly compiled

Demonstrate the commands you used to **install the cross-compiling tools for each Architecture**:
```bash
# ppc64le

# mips32le

# arm32le

```

**If you chose to compile each binary individually**, provide the commands you used to compile each file:
```bash
# ppc64le

# mips32le

# arm32le

```
